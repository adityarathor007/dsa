{
  "Init": {
    "prefix": "init",
    "body": [
      "#include <iostream>",
      "using namespace std;",
      "",
      "int main() {",
      "",
      "",
      "",
      "    return 0;",
      "}"
    ],
    "description": "A basic C++ Hello World program"
  },

  "init_cp": {
    "prefix": "init_cp",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "",
      "int main() {",
      "   ifstream infile(\"input.txt\");",
      "   int t;",
      "   infile >> t;",
      "   infile.ignore();",
      "   while(t--){",
      "       //C-1: for vector input: infile >> vec[i]; and the numbers in the input file should be space seperated",
      "       //C-2: if number of elements in the vector is not provided(after infile of t do infile.ignore() to remove the nextLine character from the buffer)",
      "       //string line;",
      "       //getline(infile,line);",
      "       //stringstream ss(line);",
      "       //vector<int>arr;       ",
      "       //int num;               ",
      "       //while(ss>>num) arr.push_back(num);",
      "                               ",
      "   }",
      "return 0;",
      "}"
    ]
  },

  "TreeNode": {
    "prefix": "init_treenode",
    "description": "Binary Tree Node structure",
    "body": [
      "struct TreeNode{",
      "    int val;",
      "    TreeNode* left;",
      "    TreeNode* right;",
      "",
      "    TreeNode(int num){",
      "        val = num;",
      "        left = NULL;",
      "        right = NULL;",
      "    }",
      "};"
    ]
  },

  "BuildTreeFromLevelOrder": {
    "prefix": "buildtree",
    "description": "Function to build binary tree from level order traversal vector",
    "body": [
      "TreeNode* buildTreeFromLevelOrder(vector<string>& level_order){",
      "    if(level_order.empty() || level_order[0] == \"N\") return nullptr;",
      "    TreeNode* root = new TreeNode(stoi(level_order[0]));",
      "",
      "    queue<TreeNode*> q;",
      "    q.push(root);",
      "",
      "    int i = 1;",
      "    int num_nodes = level_order.size();",
      "",
      "    while(!q.empty() && i < num_nodes){",
      "        TreeNode* node = q.front();",
      "        q.pop();",
      "",
      "        if(i < num_nodes && level_order[i] != \"N\"){",
      "            TreeNode* leftNode = new TreeNode(stoi(level_order[i]));",
      "            q.push(leftNode);",
      "            node->left = leftNode;",
      "        }",
      "        i++;",
      "",
      "        if(i < num_nodes && level_order[i] != \"N\"){",
      "            TreeNode* rightNode = new TreeNode(stoi(level_order[i]));",
      "            q.push(rightNode);",
      "            node->right = rightNode;",
      "        }",
      "        i++;",
      "    }",
      "",
      "    return root;",
      "}"
    ]
  },

   "ListNode": {
    "prefix": "init_llnode",
    "description": "Linked List Nodes init",
    "body": [
      "struct ListNode{ ",
      "  int val;",
      "  ListNode *next;",
      "  ListNode():val(0),next(nullptr) {}",
      "  ListNode(int x): val(x),next(nullptr) {}",
      "  ListNode(int x, ListNode *next): val(x),next(next) {}",
      "}"
    ]
  },

  "CreateLL": {
    "prefix": "create_ll",
    "description": "create LL from array",
    "body": [
      "ListNode* createLL(vector<int>arr){",
      "  ListNode* head=new ListNode(arr[0]);",
      "  ListNode *t1=head;",
      "  for(int i=1;i<arr.size();i++){",
      "      t1->next=new ListNode(arr[i]);",
      "      t1=t1->next;",
      "  }",
      "return head;",
      "}"
    ]
  }

}
